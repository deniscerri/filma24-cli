#!/bin/bash

user_agent="Chrome/97"
root_path="$HOME"
base_url="https://www.filma24.id"
newline=$'\n'
file_size=0
url_retries=0
season=0
media_type=''
interactive=0

help_text(){
	while IFS= read -r line; do
		echo $line
	done <<-EOF	
		Usage:
		    f24 [options] [input title or file]
		Examples:
		    f24 -m [Movie Title or URL]
		    f24 -t [Series Title or URL]
		Options:
		   -h show this page
		   -m sets media type as movie
		   -t sets media type as tv series
		   -s set a particular season to download. By default it downloads all seasons
		   -o set a custom download path. By default it downloads in your Downloads folder
		   -i use interactive mode when searching, instead of the script picking it itself
		   You can Also use .txt files containing lists of titles or url's as input
	EOF
}


parsevidmoly(){
        fixedURL=$(echo "$referer" | sed 's/embed-//g')
        videoID=$(echo "$fixedURL" | sed 's/https:\/\/vidmoly.net\///g' | sed 's/https:\/\/vidmoly.to\///g' | sed 's/.html//g')

        videoHash=$(curl --connect-timeout 10 -s -i -H "Accept: text/html" -H "Content-Type: text/html" -X GET "https://vidmoly.net/dl?op=download_orig&id=$videoID&mode=&hash=" |
 grep -o -E 'name="hash" value=".*"' | grep -o -P 'value="\K[^"]*')
	
	if [ -z "$videoHash" ]
	then
		return
	fi	

        page_with_mp4=$(curl -s -i -H "Accept: text/html" -H "Content-Type: text/html" -X GET "https://vidmoly.net/dl?op=download_orig&id=$videoID&mode=n&hash=$videoHash")
        mp4=$(echo "$page_with_mp4" | grep -o -E '*https://.*([^"])*.mp4' | head -1)
	
        if [ -z "$mp4" ]
		then
			if [[ $url_retries -gt 10 ]]
			then
				url_retries=0
				return 1
			else
				timeout=$(echo $page_with_mp4 | grep -o -E '*<b class="err">You have to wait[^"<b]*' | tr -dc '0-9')
				
				if [ ! -z "$timeout" ]
						then
								echo "Timeout found. Waiting $timeout seconds"
								sleep $timeout
						fi
				((url_retries=url_retries+1))
				parsevidmoly
			fi
		else
				download $referer $mp4
		fi
}

download () {
	if [ -z "$2" ]
	then
		echo "Couldn't find a suitable stream! :("
		return
	fi
	echo "Starting Download from Host $1..."
	if [[ $2 == *"m3u"* ]]
	then
		ffmpeg -http_persistent 0 -nostdin -hide_banner -v warning -stats -headers "Referer: $1" -i "$2" -c copy "$download_path" || true
	else
		ffmpeg -nostdin -hide_banner -v warning -stats -headers "Referer: $1" -i "$2" -c copy "$download_path" || true
	fi
	
	chosen_mp4=''
	chosen_referer=''
}

check_http () {
	if [ -z $1 ]
	then
		return
	fi
	http=$(echo "$1" | grep "^http" | wc -c)
	if [ "$http" -eq 0 ]
	then
		referer="https:$(echo $1 | xargs echo -n)"
	else
		referer=$1
	fi
}

pick_mp4 () {
	size_tmp=$(ffprobe -headers "Referer: $1" -i "$2" -show_entries format=size -v quiet -of csv="p=0" | tr -dc '0-9')
	if (( size_tmp > file_size ));
	then	
		file_size=$size_tmp
		chosen_mp4=$2
		chosen_referer=$1
	fi
}


get_video_link () {
	mp4=$(curl --connect-timeout 10 --user-agent "$user_agent" -s "$1" | grep -o -E '*https://.*([^"]*.m3u8.*)' | sed "s/\",\"/\n/g;s/\"//g;s/'//g;s/',//g;s/m3u8,/m3u8/g" | head -n 1)
	#Checking if the referer contains a mp4 file instead of a m3u file
	if [ -z "$mp4" ]
	then	
		mp4="$(curl --connect-timeout 10 --user-agent "$user_agent" -s "$1" | grep -o -E '*https://.*([^"]*v.mp4.*)' | grep -o '[^{,"]\+"' | sed 's/"//g' | sed "s/'//g" | grep -o -E 'http.*' | head -1)"	
	fi
	
	echo $1
	echo $mp4
}

parse_embed_referer () {

	nr_of_servers=$(curl --user-agent "$user_agent" -s $1 | grep -o -E '.*<a data-servera=".*' | wc -l | tr -dc '0-9')
	for ((i = 1 ; i <= $nr_of_servers ; i++))
	do
		
		server="$1?server=$i"	
	
		referer="$(curl --user-agent "$user_agent" -s $server | grep -o -E '*<p><iframe.*' | tr -d '"' | grep -o -P 'src=\K[^ ]*' | xargs echo -n)"		
		if [ -z "$referer" ]
		then
			continue
		fi
		
		check_http $referer
			
		result_title=$(curl --user-agent "$user_agent" -s $server | tr -d "\n" | grep -o -E '<div class="title">[[:space:]]*<h2>([^"]*)</h2>' | grep -o -P '<h2>\K[^"]*' | sed 's/<\/h2>//g')
		fix_title
		
		if [[ $media_type == "series" ]]
		then
			season_nr=$(echo "$episode_label" | grep -o -P 'Sezoni \K[^ ]*')
			episode_nr=$(echo "$episode_label" | grep -o -P 'Episodi \K[^"]*' | tr -d " (I FUNDIT)")
			download_path="$root_path/$result_title/$result_title - S${season_nr}E${episode_nr}.mkv"
			
			if [ -f "$download_path" ]
			then
				echo "Episode is Downloaded."
				return
			fi
		
		else	
			download_path="$root_path/$result_title.mkv"
			
			if [ -f "$download_path" ]
			then
				echo "Movie is Downloaded."
				return
			fi
		fi		

		
		
		if [[ $referer == *"vidmoly"* ]]
		then
			echo $referer
			parsevidmoly
			continue
		fi		
		
		get_video_link $referer
		
		if [[ $mp4 == *"m3u"* ]]
		then
			download $referer $mp4
			
		fi

		pick_mp4 $referer $mp4
	done
	
        if [[ -f "$download_path" ]]
	then
		return 0
	else
		download $chosen_referer $chosen_mp4
	fi
}

parse_seasons () {
	episode_list=$(curl --user-agent "$user_agent" -s "$1" | tr -d '\n' | grep -o -E '<div class="under-thumb seriale">[[:space:]]*<a href="([^"]*)"><h4>([^"]*)</h4\S' | tac)
		
	if [ -z "$episode_list" ]
	then
		echo "Series $query not found! :("
		return
	fi
	#If user input was an url, result_title was never initiated
	if [ -z "$result_title" ]
	then
		result_title=$(curl --user-agent "$user_agent" -s "$1" | tr -d "\n" | grep -o -E '<div class="category-head">[[:space:]].*<h3>([^"]*)</h3>' | grep -o -P '<h3>\K[^"]*' | sed 's/<\/h3>//g')
		fix_title
	fi
	echo "Creating Series Folder"
	mkdir -p "$root_path/$result_title"
	if [ $season -gt 0 ]
	then
		episode_list=$(echo "$episode_list" | grep -o -E ".*Sezoni $season.*")
	fi
		
	if [ -z "$episode_list" ]
	then
		echo "Season not Found! :("
		return
	fi

	
	echo "$episode_list" | while IFS= read -r line ; do
		episode_label=$(echo "$line" | grep -o -P 'h4>\K[^<]*')
		episode_url=$(echo "$line" | grep -o -E 'https.*/"' | tr -d "\"")

		echo "Downloading $episode_label"
		parse_embed_referer "$episode_url"
	done


}

fix_title(){
        result_title=$(echo $result_title | sed 's/ *$//; s/&nbsp;/ /g; s/&amp;/\&/g; s/&lt;/\</g; s/&gt;/\>/g; s/&quot;		/\"/g; s/#&#39;/\'"'"'/g; s/&ldquo;/\"/g; s/&rdquo;/\"/g; s/&#8217;/\'"'"'/g;')
}


search () {
	query=$(echo "$query" | sed -e 's/ /%20/g')
	url_title=$(curl --user-agent "$user_agent" -s "$base_url/search/$query" | tr -d '\n' | grep -o -E  '<div class="under-thumb">[[:space:]]*<a href="([^"]*)" title="([^"]*)"\S')
	if [ -z "$url_title" ]
	then
		echo "Media $title was not found! :("
		return
	fi
	
	if [ $interactive -eq 1 ]
	then
		titles=$(echo "$url_title" | grep -o -P 'title="\K[^"]*' | awk '{print NR". "$0}')
		result_nr=$(echo "$titles" | awk 'END{print NR}')
		
		if [ $result_nr -eq 1 ]
		then
			echo "Only one result found. [$titles]"
			echo "Continuing..."
			parse_title "$url_title"
		else				
			echo "$titles" | while IFS= read -r line ; do				
				echo -e "\e[93m$line"
				read line
				echo -e "\e[96m$line"
			done
			echo -e "\e[39m"
			printf "Write a number between [1-$result_nr]: "
			read choice
			if ! [ $choice -eq $choice 2>/dev/null ]
			then
				choice=0
			fi
			while [ $choice -lt 1 ] || [ $choice -gt $result_nr ]
			do				

				printf "Wrong Input. Try Again: "
				read choice	
				if ! [ $choice -eq $choice 2>/dev/null ]
				then
					choice=0
				fi
			done
			url_title=$(echo "$url_title" | head -n $choice | tail -n 1)
			parse_title "$url_title"
		fi
			
	else
		echo "$url_title" | while IFS= read -r line ; do
			parse_title "$line"
		done
	fi

}

parse_title(){
	result_url=$(echo "$1" | grep -o -E 'https.*/')
	
	if [[ $result_url == *serial* ]] && [[ $media_type == "movie" ]]
	then
		return
	elif [[ ! $result_url == *serial* ]] && [[ $media_type == "series" ]]
	then
		return
	fi

	#Extracts text that is inside the title tag.
	#Sed removes the space left out in the end
	result_title=$(echo "$1" | grep -o -P 'title="\K[^"]*')
	fix_title
	
	if [[ $result_title == *"$input_text"* ]]
	then	
		if [[ $media_type == "movie" ]]
		then
			parse_embed_referer $result_url
			return
		else
			parse_seasons $result_url
			return
		fi
	fi
}


while getopts 'm:t:his:o:' OPT; do
	case $OPT in
		h)
			help_text
			exit 0
			;;
		m)
			media_type="movie"
			query=$OPTARG
			;;
		t)
			media_type="series"
			query=$OPTARG
			;;
		s)
			season=$OPTARG
			;;
		o)
			root_path=$OPTARG
			if ! [ -d "$root_path" ]
			then
				echo "Given Directory does not exist!"
				exit 1
			fi
			;;
		i)
			interactive=1
			;;
		*)
			help_text
			exit 1
			;;
	esac
done

if [ $# -eq 0 ]
then
	help_text
	exit 0
fi

if [ -z "$media_type" ]
then
	echo "You need to provide the media type! $newline"
	exit 1
fi

if [ -z "$query" ]
then
	echo "You need to provide a query! $newline"
	exit 1
fi

init_start(){
	if [[ $query == *"http"* ]]
	then
		if [ "$media_type" = "movie" ]
		then
			parse_embed_referer $query
		else
			parse_seasons $query
		fi
	else
		search
	fi
}


if [[ $query == *.txt ]]
then
	txt_file=$query
	if ! [ -f "$query" ]
	then
		echo "Txt file could not be found!"
		exit 1
	fi

	while IFS= read -r line
	do
		query=$line
		echo "Searching for $query ..."
		init_start
	done < "$txt_file"
else
	init_start
fi

